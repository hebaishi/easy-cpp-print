#include <iostream>
#include <type_traits>
#include <set>
#include <map>
#include <unordered_map>
#include <tuple>
#include <utility>

struct default_delimiter{

    // Set specialisation
    template<typename T> static std::string get_start_delim(std::set<T>) { return std::string("{"); };
    template<typename T> static std::string get_elem_delim(std::set<T>) { return std::string(", "); };
    template<typename T> static std::string get_end_delim(std::set<T>) { return std::string("}"); };

    // Map delimiters
    template<typename T1, typename T2> static std::string get_start_delim(std::map<T1, T2>) { return std::string("{"); };
    template<typename T1, typename T2> static std::string get_elem_delim(std::map<T1, T2>) { return std::string(", "); };
    template<typename T1, typename T2> static std::string get_end_delim(std::map<T1, T2>) { return std::string("}"); };

    // Unordered map delimiters
    template<typename T1, typename T2> static std::string get_start_delim(std::unordered_map<T1, T2>) { return std::string("{"); };
    template<typename T1, typename T2> static std::string get_elem_delim(std::unordered_map<T1, T2>) { return std::string(", "); };
    template<typename T1, typename T2> static std::string get_end_delim(std::unordered_map<T1, T2>) { return std::string("}"); };

    // Pair delimiters
    template<typename T1, typename T2> static std::string get_start_delim(std::pair<T1, T2>) { return std::string("("); };
    template<typename T1, typename T2> static std::string get_elem_delim(std::pair<T1, T2>) { return std::string(", "); };
    template<typename T1, typename T2> static std::string get_end_delim(std::pair<T1, T2>) { return std::string(")"); };

    // Tuple delimiters
    // Same as pair since a tuple is a generalised pair
    template<typename ...Targs> static std::string get_start_delim(std::tuple<Targs...>) { return std::string("("); };
    template<typename ...Targs> static std::string get_elem_delim(std::tuple<Targs...>) { return std::string(", "); };
    template<typename ...Targs> static std::string get_end_delim(std::tuple<Targs...>) { return std::string(")"); };

    // Default delimiters
    template<typename T> static std::string get_start_delim(T) { return std::string("["); };
    template<typename T> static std::string get_elem_delim(T) { return std::string(", "); };
    template<typename T> static std::string get_end_delim(T) { return std::string("]"); };

};

template <typename T>
struct is_tuple{
    static const bool value = false;
};

template <typename ...Targs>
struct is_tuple<std::tuple<Targs...>>{
    static const bool value = true;
};

// Helper struct to determine
// whether a type contains an iterator
// member / type
template <typename T>
struct has_const_iterator_helper{

    template <typename C>
    static std::true_type f(typename C::const_iterator*);

    template <typename C>
    static std::false_type f(...);

    typedef decltype(f<T>(0)) type;
};

template <typename T>
typename has_const_iterator_helper<T>::type
return_has_const_iterator(T& val) {
    typename has_const_iterator_helper<T>::type ret_val;
    return ret_val;
}

template <typename T, typename DELIMITER>
void print_iterator_helper(std::false_type, std::ostream& os, const T& cont, DELIMITER &delim) {
    os << cont;
}

template <typename TChar, typename DELIMITER>
void print_iterator_helper(std::true_type, std::ostream& os, const std::basic_string<TChar>& cont, DELIMITER &delim) {
    os << "\"" << cont << "\"";
}

// Functions to recursively print tuples
template <size_t I, typename T, typename DELIMITER>
typename std::enable_if<(!is_tuple<T>::value), void>::type
print_tuple(std::ostream& os, const T& cont, DELIMITER &delim) {
    print_iterator_helper(return_has_const_iterator(cont), os, cont, delim);
}

template <size_t I, typename ...Targs, typename DELIMITER>
typename std::enable_if<(I == sizeof...(Targs)), void>::type
print_tuple(std::ostream& os, const std::tuple<Targs ...>& tup, DELIMITER &delim) {
    os << delim.get_end_delim(tup);
}

template <size_t I, typename ...Targs, typename DELIMITER>
typename std::enable_if<(I < sizeof...(Targs) && I != 0), void>::type
print_tuple(std::ostream& os, const std::tuple<Targs ...>& tup, DELIMITER &delim) {
    os << delim.get_elem_delim(tup);
    auto val = std::get<I>(tup);
    print_tuple<I>(os, val, delim);
    print_tuple<I+1>(os, tup, delim);
}

template <size_t I, typename ...Targs, typename DELIMITER>
typename std::enable_if<(I == 0), void>::type
print_tuple(std::ostream& os, const std::tuple<Targs ...>& tup, DELIMITER &delim) {
    os << delim.get_start_delim(tup);
    auto val = std::get<I>(tup);
    print_tuple<I>(os, val, delim);
    print_tuple<I+1>(os, tup, delim);
}

// Pair specialisation
template <typename T1, typename T2, typename DELIMITER>
void print_iterator_helper(std::false_type, std::ostream& os, const std::pair<T1, T2> &cont, DELIMITER &delim) {
    os << delim.get_start_delim(cont);
    print_iterator_helper(return_has_const_iterator(cont.first), os, cont.first, delim);
    os << delim.get_elem_delim(cont);
    print_iterator_helper(return_has_const_iterator(cont.second), os, cont.second, delim);
    os << delim.get_end_delim(cont);
}

// Specialisation for tuples
// Passes control to tuple printing
// functions
template <typename ...Targs, typename DELIMITER>
void print_iterator_helper(std::false_type, std::ostream& os, const std::tuple<Targs...> &cont, DELIMITER &delim) {
    print_tuple<0>(os, cont, delim);
}

// Recursive function to print iterators
template <typename T, typename DELIMITER>
void print_iterator_helper(std::true_type, std::ostream& os, const T& cont, DELIMITER &delim) {
    os << delim.get_start_delim(cont);
    if (!cont.empty()) {
        auto it = cont.begin();
        print_iterator_helper(return_has_const_iterator(*it), os, *it, delim);
        it++;
        for (; it != cont.cend() ; it++) {
            os << delim.get_elem_delim(cont);
            print_iterator_helper(return_has_const_iterator(*it), os, *it, delim);
        }
    }
    os << delim.get_end_delim(cont);
}

// User-facing functions
template <typename T>
void print(std::ostream& os, const T& container) {
    default_delimiter delim;
    print_iterator_helper(return_has_const_iterator(container), os, container, delim);
}

template <typename T, typename DELIMITER>
void print(std::ostream& os, const T& container, DELIMITER &delim) {
    print_iterator_helper(return_has_const_iterator(container), os, container, delim);
}
